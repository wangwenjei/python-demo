此次节详细代码看app03

## 准备测试脚本
```python
"""
当你只是想测试django中的某一个py文件内容 那么你可以不用书写前后端交互的形式
而是直接写一个测试脚本即可

脚本代码无论是写在应用下的tests.py还是自己单独开设py文件都可以
"""
# 测试环境的准备 去manage.py中拷贝前四行代码 然后自己写两行
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "day64.settings")
    import django

    django.setup()
    # 在这个代码块的下面就可以测试django里面的单个py文件了

# Django3 中  不仅仅需要 manage.py的前四行 还需要后两行
import os
import sys


def main():
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mysite.settings')
    ...


if __name__ == '__main__':
    main()  
```


## 单表操作
```python
    "增"
res = models.User.objects.create(name='jason', age=18, register_time='2021-01-01')
print(res)  # ===> User object (2)  返回值就是被创建的对象本身

import datetime

ctime = datetime.datetime.now()
user_obj = models.User(name='jason2', age=18, register_time=ctime)
user_obj.save()

"删"
res = models.User.objects.filter(pk=6).delete()
print(res)  # ==> (1, {'app03.User': 1})  1 是影响的行数
"""
    pk 会自动查找当前表的主键字段, 指代的就是当前表的主键字段
    用来pk后 就不需要查看当前表的主键字段叫id sid 还是 pid了
"""

user_obj = models.User.objects.filter(pk=8).first()
res = user_obj.delete()
print(res)  # ==> (1, {'app03.User': 1})

"改"
models.User.objects.filter(pk=9).update(name='vivi')

user_obj = models.User.objects.get(pk=10)
user_obj.name = 'tom'
user_obj.save()
print(user_obj)  # ===> User object (9)
"""
    get 方法返回的直接就是当前数据对象
    但是该方法不推荐使用 
        一旦数据不存在该方法会直接报错  而 filter 则不会 所以推荐使用 filter
"""

"查"
res = models.User.objects.all()  # 查询全部
res = models.User.objects.first()  # 查询第一条
```


## 关于查询必会
```python
"""
    all()        # 1.查询所有数据
    filter()     # 2.带有过滤条件的查询,且展示第一条数据
    get()        # 3.直接拿数据对象 但是条件不存在直接报错
    
    first()      # 4.拿QuerySet里第一个元素
    last()       # 5.拿QuerySet里最后一个元素
    
    values()     # 6.可以指定获取的数据字段            <QuerySet [{'name': 'jason', 'age': 18}]>
    values_list  # 7.可以看成是类似于元组嵌套列表的形势  <QuerySet [('jason', 18)]>
    
    distinct()   # 8.去重 注意当包含主键主键字段时数据永远不会重复   models.User.objects.values('name').distinct()
    
    order_by()   # 9.排序 默认升序 
        models.User.objects.order_by('age')  升序
        models.User.objects.order_by('-age') 降序
        
    reverse()   # 10.反转  反转的前提是数据已经排序过了,否则反转无效
    count()     # 11.统计当前数据个数
    exclude()   # 12.排出在外
    exists()    # 13.返回的是布尔值 基本用不到因为数据本身就自带布尔值
"""
```


## 双下划线查询
```python

"""
int 
    age__gt     大于  
    age__lt     小于
    age__gte    大于等于
    age__lte    小于等于
    age__in[]   或
    age__range  范围
    
str
    name__contains  模糊查询 不区分大小写
    name_icontains  模糊查询 区分大小写
    
日期
    register_time__year   年
    register_time__month  月

"""

```


## 查看内部SQL语句方式
```python
# 方式1
# queryset对象才能够点击query查看内部的sql语句
res = models.User.objects.values_list('name', 'age')
print(res.query)  # SELECT `app03_user`.`name`, `app03_user`.`age` FROM `app03_user`

# 方式2:所有的sql语句都能查看
# 去配置文件中配置一下即可
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
        },
    },
    'loggers': {
        'django.db.backends': {
            'handlers': ['console'],
            'propagate': True,
            'level': 'DEBUG',
        },
    }
}
```


## 一对多外键增删改查
```python
"增"
# 直接写实际字段ID
models.Book.objects.create(title='三国演义', price='665.78', publish_id=2)

# 虚拟字段 放对象
publish_obj = models.Publish.objects.filter(pk=1).first()
models.Book.objects.create(title='水浒传', price='664.97', publish=publish_obj)

"删"
# 删除是级联删除的,删除了出版社则出版社下的书籍也会被对应删除
models.Publish.objects.filter(pk=3).delete()

"改"
# 方法一:
models.Book.objects.filter(pk=2).update(publish_id=2)

# 方法二:
publish_obj = models.Publish.objects.filter(pk=3).first()
models.Book.objects.filter(pk=2).update(publish=publish_obj)
```


## 多对多外键增删改查
```python
"""多对多外键增删改查"""
# 首先需要获取到对应的书籍对象
book_obj = models.Book.objects.filter(pk=1).first()  # 获取到书籍ID为1的对象
print(book_obj.authors)  # book_obj.authors 就相当于到了第三张关系表

"增"
#   add 为第三张关系表添加数据   括号内既可以传数字也可以传对象 并且都支持多个
# 方式一:
book_obj.authors.add(1, 2)  # 为书籍ID为1的书籍绑定一个主键为1和2 的作者
# 方式二:
author_obj = models.Author.objects.filter(pk=3).first()
book_obj.authors.add(author_obj)

"删"
# 方式一:
book_obj.authors.remove(1, 2)
# 方式二:
author_obj = models.Author.objects.filter(pk=3).first()
book_obj.authors.remove(author_obj)

"改"  # 括号内必须是一个可迭代对象
# 方式一: 
book_obj.authors.set([1, 2])
# 方式二: 
author_obj = models.Author.objects.filter(pk=3).first()
book_obj.authors.set([author_obj])

"清空"
#  在第三张关系中清空某个书籍与作者的绑定关系
book_obj.authors.clear()
"""
    clear 括号内不要加任何参数
"""
```


## 正向/反向查询概念

```text
正向: 外键字段在我手上,我去查找你就是正向
反向: 外键字段不在手上,我去查找你就是反向

book >>> 外键字段在书哪里(正向) >>> publish
publish  >>> 外键字段在书哪里(反向) >>>  book

总结:
    正向查询按字段
    反向查询按表名小写 有时需要加_set  ...
    
```


## 多表查询
### 子查询(基于对象的跨表查询)(基于外键)
```python
    """  子查询  """
"""  
    子查询  
          正向查询什么时候需要加.all()
                当你的结果可能有多个的时候就需要加.all()
                如果是一个则直接拿到数据对象
                   eg:  book_obj.publish  获取出版社,每本书只能有一个出版社
                        book_obj.authors.all()  一本书可以有多个联合作者
                        book_obj.author_detail  每个作者与作者详情都是一一对应的
                        
          反向查询什么时候需要加_set.all()
                当你的查询结果可以有多个时 就必须加_set.all()
                当你的结果只有一个的时候 不需要加_set.all()
"""
"  正向查询  "
# 1.查询书籍主键为1的出版社
book_obj = models.Book.objects.filter(pk=1).first()
print(book_obj.publish.name)  # ==> 北方出版社

# 2.查询书籍主键为2的作者
book_obj = models.Book.objects.filter(pk=2).first()
print(book_obj.authors)  # ==> app03.Author.None
print(book_obj.authors.all())  # ==> <QuerySet [<Author: Author object (3)>]>

# 3.查询作者Jason的电话号码
author_obj = models.Author.objects.filter(name='jason').first()
print(author_obj.author_detail.phone)  # ==> 18211111111

"  反向查询  "
# 4.查询出版社是东方出版社出版的书
publish_obj = models.Publish.objects.filter(name='北方出版社').first()
print(publish_obj.book_set.all())  # ==> <QuerySet [<Book: Book object (1)>, <Book: Book object (4)>]>

# 5.查询作者是jason写过的书
author_obj = models.Author.objects.filter(name='jason').first()
print(author_obj.book_set.all())  # ==> <QuerySet [<Book: Book object (1)>, <Book: Book object (3)>]>

# 6.查询手机号是18311111111
author_detail_obj = models.AuthorDetail.objects.filter(phone=18311111111).first()
print(author_detail_obj.author.name)  # ==> tom


```


### 连表查询(基于外键)
```python
    """  连表查询  """
# 1.查询jason的手机号和作者姓名
# 正向
res = models.Author.objects.filter(name='jason').values('name', 'author_detail__phone')
print(res)
# 反向
res1 = models.AuthorDetail.objects.filter(author__name='jason').values('author__name', 'phone')
print(res1)

# 2.查询书籍主键为1的书籍名称和 出版社名称
# 正向
res = models.Book.objects.filter(pk=1).values('title', 'publish__name')
print(res)
# 反向
res1 = models.Publish.objects.filter(book__id=1).values('book__title', 'name')
print(res1)

# 3.查询书籍主键为1 的作者姓名和书籍名称
# 正向
res = models.Book.objects.filter(pk=1).values('authors__name', 'title')
print(res)
# 反向
res1 = models.Author.objects.filter(book__pk=1).values('name','book__title')
print(res1)

# 4.查询书籍主键是1的作者的姓名和手机号
# 正向
res = models.Book.objects.filter(pk=1).values('authors__name','authors__author_detail__phone')
print(res)
# 反向
res1 = models.Author.objects.filter(book__pk=1).values('name','author_detail__phone')
print(res1)

```
