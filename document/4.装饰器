装饰器

装饰器: 
	定义一个函数,该函数是用来为其他函数添加额外的功能
	装饰器就是在不修改被装饰器对象源代码以及调用方式的前提下为被装饰对象添加新功能
为什么要用装饰器
	开放封闭原则:
		开放: 指的是对拓展功能是开放的
		封闭: 指的是对修改源代码是封闭的
	

装饰器案例: 
	import time
	def outtter(func_def):  # 装饰器
	    def wrapper(*args, **kwargs):
	        start = time.time()
	        res = func_def(*args, **kwargs)
	        stop = time.time()
	        print("timeout:", stop - start)
	        return res

	    return wrapper

	def index(x, y, z):  # 装饰对象
	    time.sleep(1)
	    print('index====> %s,%s,%s' % (x, y, z))
	    return 12345

	index = outtter(index)
	print(index(1, 3, 4))


语法糖: 快速为装饰对象调用装饰器
	import time

	def outtter(func_def):
	    def wrapper(*args,**kwargs):
	        start = time.time()
	        res = func_def(*args,**kwargs)
	        stop = time.time()
	        print("timeout:",stop - start)
	        return res
	    return wrapper

	    	  # 在被装饰器对象正上方的单独一行写 @装饰器名字
	@outtter  # 等同于 ndex = outtter(index)
	def index(x,y,z):  
	    time.sleep(1)
	    print('index====> %s,%s,%s' %(x,y,z))
	    return 12345

	print(index(1,3,4))


有参装饰器:
	def auth(db_type):
	    def deco(func):
	        def wrapper(*args,**kwargs):
	            name = input("you name>>>:").strip()
	            passwd = input("you passwd>>>:").strip()

	            if db_type == 'file':
	                print('基于文件验证')

	                if name == "wwj" and passwd == "123":
	                    res = func(*args, **kwargs)
	                    return res
	                else:
	                    print("user or password error")

	            elif db_type == 'mysql':
	                print('基于MySQL验证')
	            else:
	                print('不支持该验证方法')
	        return wrapper
	    return deco


	@auth(db_type='file')
	def index(x,y):
	    print("index===>%s,%s" %(x,y))

	index(x=1,y=2)


无参装饰器模板:
	def outter(func):  # 装饰器
		def wrapper(*args,**kwargs):
			# 1.调用原函数
			# 2.为其增加新功能
			res = func(*args,**kwargs)
			return res
		return wrapper

	@outter  # 调用装饰器
	def index():  # 被装饰对象
		pass
	index()

有参装饰器模板:
	def auth(x,y,z):
	    def outter(func):
	        def wrapper(*args, **kwargs):
	            res = func(*args, **kwargs)
	            return res
	        return wrapper
	    return outter

	@auth(1,y=2,z=3)
	def index():
	    pass
	index()

叠加多个装饰器的加载顺序与运行顺序
	加载顺序是自下而上(了解)
	执行顺序是 
		自上而下 即 wrapper1 >>> wrapper2 >>> wrapper3

