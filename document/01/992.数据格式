输入
name=input("input you name:")


输出
print("hello Python")


格式化输出
1.%s  (%s:接收任意类型数据,%d:接收数字类型)
	值按照位置与%s一一对应,少一个不行,多一个不行

	以字典的形式传值,打破位置的限制
	res = "my name is %(name)s,age is %(age)s" %{"name":'wwj',"age":18}

2.str.for mat  str类型下内置的功能  推荐使用
	res = "my name is {name},age is {age}".format(age=18,name='wwj')

3. f  python 3.5后推出
	x = input("input you name:")
	y = input("input you age:")
	res = f"my name is {x},age is {y}"








通常用全大写表示常量,全小写表示变量
链式赋值
	x=y=z=10

交叉赋值
	x=10
	y=20
	x,y=y,x

解压赋值
	x=[1,2,3,4,5]
	x1,x2,x3=x[0:3]

	
	x1,x2,*_=x  取前两个值,其余存到*_
	*_,x1,x2=x  取后两个值,其余存到*_
	x1,*_,x2=x









可变不可变类型
	可变类型: 值改变,id不变,证明改的是原值,证明原值是可以改变的
		list,dict 容器内的值发生了变化,容器本身内存地址并没有改变

	不可变类型: 值改变,id也变了,证明是产生新的值,压根没有改变原值,证明原值是不可被修改的
		int,float,str 在Python中都被设计成了不可分割的整体,不能够被改变
		bool 不可变

显示bool值: True False
隐式bool值: 0 None 空(空字符串,空列表,空字典) 代表的布尔值为












逻辑运算符
	not: 就是吧紧跟其后的那个条件取反,not与紧跟其后的那个条件是一个不可分割的整体
	and: 与,链接左右两个条件,两个条件同时为真则为真
	or:  或,链接左右两个条件,其中一个条件为真就为真

	优先级
	not>and>or

成员运算符
	in: 
	"wwj" in "hello wwj"  判断一个子字符串是否存在于一个大字符串中
	1 in [1,2,3]  判断一个元素是否存在于列表
	"name" in {"name":"wwj","age":18}  判断key是否存在于字典

	not in
	"wwj" not in "hello wwj"

身份运算符
	is: 判断的是id是否相等









深浅copy:
	a=[1,2,3,['a','b']]

	浅copy: 是把原列表第一层的内存地址不加区分完全copy一份给新列表
		b = a.copy()
		修改a[3][0]='aaa' 时 b列表也随之更改

	深copy:
		import copy
	    b = copy.deepcopy(a) 
		修改a[3][0]='aaa' 时 b列表也不会更改
  

 break与continue
 	continue 语句跳出本次循环，而break跳出本层循环


bin() 十进制转二进制
oct() 十进制转八进制
hex() 十进制转十六进制
int('0b1011',2) 其他进制转为十进制(此处是二进制转十进制)

len() 计算字符串,列表,集合,元组长度
range(len())
del   删除,且没有返回值








字符串: 常用内置方法 len()  strip()   split()
	a="  hello world  "
	print( a[-2] )     可以安索引取值
	print( a[0:8:2] )  切片,顾头不顾尾
	print( a[::-1] )	   翻转字符串

	print('hello' in  a)         成员运算
	print('hello' not in  a)

	print( a.strip('\n') )   去除字符串左右符号,默认空格( lstrip()去左边 rstrip()去右边 )
	print(a.split(':',1))   split() 字符串切分,默认按空格,切分次数为所有

	print(a.lower())	字符串全小写
	print(a.upper())	字符串全大写

	startswith('hello')  字符串是否以某字符串开头	
	endswith('world')    字符串是否以某字符串结尾

	format()	格式化字符

	split()		从左往右切分为列表
	rsplit()	从右往左切分为列表

	b=['hello','world']
	print(':'.join(b))    按某个分隔符,将元素全为字符串的列表,拼接为一个大字符串

	replace("hello","HELLO",)	替换字符串,参数分别为,替换的字符串,要替换成的字符串,替换次数

	print(a.isdigit())   判断字符串是否由数字组成   


列表:
	a = [1,2,3,4,5]
	
	a.append('wwj')     在列表末尾添加值
	a.insert(3,'wwj')   指定索引位置插值

	b = ['a','b','c']
	a.extend(b)			将一个 可循环对象 取出来添加到列表中

	del a[3]	通用的删除,且不支持赋值
 	a.pop(3)	根据索引删除,不指定索引默认最后一个,返回值为删除的值
 	a.remove('c')  根据元素删除,返回None

	循环:
		for i in [1,2,3,4,5]:
    		print(i) 		

    l.count()	统计列表某一元素出现次数
    l.index()	统计列表某一元素第一次出现的索引值,找不到则报错
    l.clear()	清空列表
    l.reverse()	将列表倒过来
    l.sort()	将列表排序,默认升序(reverse=True 为降序)
 
 队列(FIFO):先进先出
 堆栈(LIFO):后进先出


元组: 一个不可变的列表
	作用:按照索引/位置存放多个值,只用于读不用于改
	注意: 如果元组中只有一个元素,必须加逗号分隔 t=(9, )


字典:
	d={}
	
	赋值: key存在则修改,不存在则添加
	d["name"] = "wwj"

	成员运算根据key

	删除:
		d.pop()  根据key删除元素,返回删除key对应的那个value值
		d.poplitem()  随机删除,返回元组(删除的 key 与 value )

	d.clear()	清理字典
	d.update()	用一个新字典更新一个老字典;老字典不存在的key添加,老字典存在的key以新字典为准
	d.get()		普通取字典值,key没有会报错;用get取没有key的返回None  建议
	d.setdefault('name':'wwj')   如果key有值则不添加,没有则添加,返回值为key对应的值



集合:  集合内元素必须为不可变类型,集合内元素无序,集合内元素没有重复,比较大小是比较是否是包含关系
	f1={'a','b','c'}
	f2={'e','f','c'}


	关系运算
		取交集	
			c = f1 & f2   ====> c 
			c = f1.intersection(f2)

		取并集	c1 = f1 | f2  ====> a b c e f 
				c1 = f1.union(f2)

		取差集(有左右顺序之分)	c2 = f1 - f2  ====> a b 
							c2 = f1.difference(f2)

		对称差集	c3 = f1 ^ f2	====> a b e f
				c3 = f1.symmetric_difference(f2)

		父子集(包含关系)	
			s1 = {1,2,3}
			s2 = {1,2}

			print(s1 > s2)    ====> True
			print(s1.issuperset(s2))   ====> True
			print(s1.issubset(s2))    ====> False


	去重: 只能针对不可变类型去重,无法保证原来的顺序

	f1.discard()	将一个元素从集合中删除,不存在不报错
	f1.remove()		删除元素不存在会报错
	f1.update()		将一个新集合加到旧集合中并去重


