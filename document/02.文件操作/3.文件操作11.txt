文件操作
open()
	控制文件读写内容的模式: t 和 b
		强调: t 和 b 不能单独使用,必须跟r/w/a连用

		t 文本 (默认模式)
			1.读写都以str(unicode)为单位
			2.文件文件
			3.必须指定encoding='utf-8'
			4.必须指定字符编码,即必须指定encoding参数

		b 二进制/bytes
			不做任何转换,直接读入内存
			读写都以bytes为单位
			可以针对所有文件,但处理文本文件不如t模式简便
			一定不能指定encoding参数


		控制文件读写操作的模式(都需要与t或b连用):
			r: 只读模式,默认模式,当文件不存在时报错,当文件存在时文件指针在最开始位置,
				f.read()	将文件一次性全读取全部内容到内存				

			w: 只写模式,当文件不存在时会创建空文件,当文件存在时会清空文件,指针在开始位置
					   在以w模式打开文件没有关闭的情况下,连续写入,新的内容总是跟在旧的之后
					   如果重新以w模式打开文件,则会清空文件内容
				f.write('Hello Python')
 
			a: 只追加写模式,只追加写,在文件不存在时会创建空文档,指针在开始位置,
				在文件存在时文件指针跳到末尾
				文件写入时追加到末尾

			+: 不能单独使用,必须配合r,w,a (了解)
				r+, 可读可写,但文件不存在直接报错
				w+, 可读可写,文件不存在创建新文件,存在则清空写入
				a+,	可读可写,文件不存在创建新文件,存在则追加写入

			x: 只写模式,不可读,文件不存在创建,存在则报错(了解)


	文件操作流程:
		打开文件:
			f = open(r'文件路径',mode='模式',encoding='utf-8')

		操作文件: 读/写文件,
			print( f.read() )

		关闭文件: 
			f.close()  # 回收操作系统资源,此时变量f存在,但不能再读写


with 上下文管理( with语法可以同时打开多个文件,并在结束时自动关闭文件 )
	with open(r'a.txt',mode='rt') as f1,open(r'b.txt',mode='rt') as f2:
	    res1 = f1.read()
	    res2 = f2.read()
	    print(res1)


with open(r'./test',mode='rt',encoding='utf-8') as f1,\
        open(r'./write',mode='wt',encoding='utf-8') as f2:
    res = f1.read()
    f2.write(res)

读取文件内容并结合字符串
with open('./write',mode='rt',encoding='utf-8') as f:
    res = f.readlines()
    old_num=''
    for i in range(len(res)):
        old_num += res[i].strip('\n') + "+"
    print(old_num.strip('+'))


b模式读文件
with open(r'./test',mode='rb') as f:
    res = f.read().decode('utf-8')
    print(res)

b模式是用bytes类型写入数据,写入时需要利用encode转字符集写入
with open(r'./b_write.txt',mode='wb') as f :
    f.write('世界,你好'.encode('utf-8'))

实现复制文件功能
with open(r'./T1.png',mode='rb') as f1,\
        open(r'./T2.png',mode='wb') as f2:
    res1 = f1.read()
    f2.write(res1)


文件过大循环读取文件
方法一:( 以字节大小为单位分隔 )
with open(r'./T1.png',mode='rb') as f,\
        open(r'./T3.png',mode='wb') as f2:
    while True:
        res = f.read(1024)  # 每次读取1024字节
        if len(res) == 0:
            break
        f2.write(res)

方法二:( 以行为单位分隔,缺点是当一行内容过大时会导致一次性读入内容的数据量过大 )
with open(r'./T1.png',mode='rb') as f:
    for i in f:
        print(i)



f.readline()    一次读一行
f.readlines()	将文件读取放到列表,列表每个元素放的是文件每一行的内容

with open('./test',mode='rt',encoding='utf-8') as f:
    while True:
        res = f.readline().strip('\n')
        if len(res) == 0:
            break
        print(res)

read()与readline,都是一次性将内容读入内存,如果内容过大会导致内存溢出,
				 若想将内容全部读入内存,则必须分多次读入,有两种实现方式:
				 方法一:while循环,方法二:for循环


f.writelines()	将列表中的内容写到文件中	

flush 刷新,强制将文件写入到硬盘,多数情况下不使用
with open(r'./write',mode='wt',encoding='utf-8') as f:
	f.write('哈哈哈')
	f.flush


文件指针操作:
	指针移动的单位都是以bytes/字节为单位,
	只用一种情况特殊:
		t模式下的read(n),n代表的是字符个数


f.seek(n,模式): n指的是移动的字节个数,只有0模式可以在t下使用,1,2必须在b模式下使用
    		   模式: 
    		   	  0: 参照物是文件开头位置   f.seek(3,0)
    		   	  1: 参照物是当前指针所在位置  f.seek(9,1)
    		   	  2: 参照物是文件末尾位置,应该倒着移动  f.seek(-5,2)


