函数

无参函数:
	def a():
		pass

有参函数:
	def a(x,y):
		print(x,y)
	a(1,2)

空函数,函数体代码为pass
	def a(x,y):
		pass


形参与实参
	形参:在定义函数阶段定义的参数称之为形势参数,简称形参,相当于变量名
		def func(x,y):
			print(x,y)
	实参:在调用函数阶段传入的值称之为实际参数,简称实参,相当于变量值
		func(1,2)

	形参与实参的关系:
		在调用阶段,实参的值会绑定给形参,
		这种绑定关系只能在函数体内使用,
		实参与形参的绑定关系在函数调用时生效,函数调用结束后解除绑定关系


位置参数: 按照从左到右的顺序依次定义的参数称之为位置参数
	位置形参:必须被传值,多一个不行少一个也不行
		def func(x,y):
			print(x,y)

	位置实参:按照顺序与形参一一对应
		func(1,2)

关键字参数:
	关键字实参:在函数调用阶段,按照key=value的形式传入的值,
			 指名道姓的给某个形参传值,可以完全不参数顺序
		func(y=2,x=1)

默认参数:
	默认形参:在定义函数阶段,就已经被赋值的形参,称之为默认参数
			在调用阶段可以不用为其赋值
		def func(x,y=3)
			print(x,y)

位置形参与默认形参混用:
	位置形参必须在默认形参左边
	默认参数的值是在函数定义阶段被赋值的,准确的说被赋予的是值的内存地址
	虽然默认默认值可以被指定为任意数据类型,但是不推荐使用可变类型
	函数最理想的状态: 函数的调用只跟函数本身有关系,不受外界代码影响

	def func(x,y,z,l=None):
		if l is None:
			l = []
		l.append(x)
		l.append(y)
		l.append(z)
		print(l)

	func(1,2,3,['a'])


可变长度的参数(*与**用法)
	可变长度指的是在调用函数时,传入的值的个数不固定,
	而实参是用来为形参赋值的,所以对应着,针对溢出的实参必须有对应的形参来接收

	可变长度的位置参数: 
		*形参名: 用来接收溢出的位置实参,溢出的位置实参会被*保存成元组的格式,然后复制给紧跟其后的形参名,
				*后跟的可以是任意名字,但是约定俗成应该是args
			def func(*args):
			    print(args)
			func(1,2,3)   ======> (1,2,3)

			def sum(*args):
			    num = 0
			    for i in args: num += i
			    print(num)
			sum(1,2,3) ===> 6

		* 还可以用在实参中,实参中带*,先将*后的值打散成位置实参
			def func(x,y,z):
				print(x,y,z)
			func(*[11,22,33])  =====>  11 22 33

		形参与实参都带*: 
			def func(x,y,*args):
			    print(x,y,args)
			func(1,2,*[3,4,5])   =====> 1 2 (3,4,5) 


	可变长度的关键字参数: 用来就收溢出的关键字实参
		**形参名: 用来接收溢出的关键字实参,**会将溢出的关键字实参保存成字典格式,然后复制给紧跟其后的形参名,
				 **后跟的可以是任意名字,但是约定俗成应该是kwargs

			def func(**kwargs):
			    print(kwargs)
			func(x=1,y=2)   =====> {'x':1,'y':2}


		**可以用在实参中(**后跟的只能是字典),实参中带**,先将**后的值打散成关键字实参
			def func(x,y,z):
				print(x,y,z)
			func(**{'x':1,'y':2,'z':3})  =====> 1 2 3


 		形参与实参都带**:
 		def func(x, y, **kwargs):
    		print(x, y, kwargs)

		func(**{'x':1,'y':2,'a':3,'b':4,'c':5})  =====> 1 2 {'a': 3, 'b': 4, 'c': 5}


	混用*与**:
		*args必须在**kwargs之前

			def func(*args,**kwargs):
			    print(args,kwargs)
			func(1,2,3,a=11,b=22,c=33)   =====> (1,2,3) {'a': 11, 'b': 22, 'c': 33}


			def index(x,y,z):
				print('index=>>> ',x,y,z)
			def wrapper(*args,**kwargs):
				index(*args,**kwargs)
			wrapper(1,z=3,y=2)


名称空间namespacs: 存放名字的地方,是对栈区划分,有了名称空间后,就可以在栈区中存放相同的名字

	内置名称空间:
		存放的名字: 存放Py解释权内置的名字
		存活周期:	 py解释器启动则产生,关闭则销毁

	全局名称空间:
		存放的名字: 只要不是函数内定义,也不是内置的,剩下的都是全局名称空间的名字
		存活周期: Py文件执行则产生,Py文件运行完毕后销毁

	局部名称空间:
		存放的名字: 在调用函数时,运行函数体代码过程中产生的函数内的名字
		存活周期: 在调用函数时存活,函数调用完毕后则销毁

	名字查找优先级: 以定义阶段为准,在当前所在位置向上一层一层查找

global与nonlocal
	如果在局部想要修改全局的名字对应的值,需要用global
		x=1
		def func():
		    global x  # 声明x这个名字是全局的名字,不要再新造的名字了
		    x = 2
		    print(x)
		func()   ====> 2
		print(x) ====> 2


函数使用:
	可以把函数当成变量去用
	可以赋值
	可以当做函数的参数传入给另外一个函数
	可以当做函数另外一个函数的返回值
	可以当做容器类型的一个元素


闭包函数=名称空间与作用域+函数嵌套+函数对象
	核心特点: 名字的查找关系是以函数定义阶段为准

	闭包函数:
		"闭"函数指的是该函数是内嵌函数
		"包"函数指的是该函数包含对外层函数作用域名字的引用(不是对全局作用域)
			def f1():
			    x = 11111
			    def f2():
			        print('函数f2:',x)
			    return f2

			x=222
			f2=f1()
			f2() =====> 函数f2: 11111


为什么要有闭包函数
	两种为函数传参的方式
		方式一:	直接吧函数体需要的参数定义成形参
			def f2(x):
				print(x)
			f2(1) ===> 1

		方式二:

			def f1(x):
			    def f2():
			        print(x)
			    return f2

			f2 = f1(111)
			f2() =====> 111


函数递归调用:	是函数嵌套调用的一种特殊形式
	具体是指:
		在调用一个函数的过程中又直接或间接地调用到本身
		递归的本质就是循环

	递归调用不应该无限的调用下去,必须在满足某种条件下结束递归调用

	递归的两个阶段:
		回溯: 一层一层调用下去
		递推: 满足某种结束条件,结束递归调用,然后一层一层返回

	list1 = [1,[2,[3,[4,[5,[6,[7,[8,[9,[10]]]]]]]]]]
	def func(l):
	    for i in l:
	        if type(i) is list:
	            func(i)
	        else:
	            print(i)

	func(list1)  ===> 1,2,3,4,5,6,7,8,9,10


匿名函数: lambda用于定义匿名函数
	lambda x,y:x+y


	s = {'zbw': 100, 'jh': 200,'lsy': 300,'qcx': 50}


	def func(k):
	    return s[k]


	res = max(s, key=func)
	print(res)

	res1 = max(s, key=lambda k: s[k])
	print(res1)



函数类型提示,
	提示name应该接收str类型,  冒号后是提示信息,提示信息可以是任意字符或表达式
	返回值应该是int类型   ->后接提示函数返回值信息,提示信息可以是任意字符或表达式
def func(name:str,age:int,hobbies:tuple)->int:
    print('我叫 %s 今年 %s 岁 爱好是 %s' %(name,age,hobbies))
    return 111

添加默认值
def func(name:str='wwj',age:int=18,hobbies:tuple=('play'))->int:
    print('我叫 %s 今年 %s 岁 爱好是 %s' %(name,age,hobbies))
    return 111

print(func.__annotations__)  # 查看函数提示信息











